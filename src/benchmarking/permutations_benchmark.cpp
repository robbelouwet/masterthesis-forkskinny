#include "../forkskinny-plus/headers/forkskinny64-plus.h"
#include "../headers/full-state-slicing.h"
#include <cstdint>
#include "cassert"
#include <iostream>
#include "cstdlib"

// for every slice: PT[9, 15, 8, 13, 10, 14, 12, 11, 0, 1, 2, 3, 4, 5, 6, 7] (source indices)
/* Permutation generated by http://programming.sirrida.de/calcperm.php */
static inline void permute_sliced_circuit(State64Sliced_16_t *tk) {
	// --------------------------------------------------- source bits: Z123 4567 89ab cdef	| Cumulative value
	tk->slices[0] = ((tk->slices[0] & 0xFF00) >> 8)     // masks:       1111 1111 0000 0000 | 0000 0000 Z123 4567
	                | ((tk->slices[0] & 0x00A8) << 6)   //              0000 0000 1010 1000 | 0080 A0C0 Z123 4567
	                | ((tk->slices[0] & 0x0040) << 9)   //              0000 0000 0100 0000 | 9080 A0C0 Z123 4567
	                | ((tk->slices[0] & 0x0010) << 4)   //              0000 0000 0001 0000 | 9080 A0CB Z123 4567
	                | ((tk->slices[0] & 0x0004) << 10)  //              0000 0000 0000 0100 | 9080 AECB Z123 4567
	                | ((tk->slices[0] & 0x0002) << 9)   //              0000 0000 0000 0010 | 908D AECB Z123 4567
	                | ((tk->slices[0] & 0x0001) << 14); //              0000 0000 0000 0001 | 9F8D AECB Z123 4567
					
	// --------------------------------------------------- source bits: Z123 4567 89ab cdef	| Cumulative value
	tk->slices[1] = ((tk->slices[1] & 0xFF00) >> 8)     // masks:       1111 1111 0000 0000 | 0000 0000 Z123 4567
	                | ((tk->slices[1] & 0x00A8) << 6)   //              0000 0000 1010 1000 | 0080 A0C0 Z123 4567
	                | ((tk->slices[1] & 0x0040) << 9)   //              0000 0000 0100 0000 | 9080 A0C0 Z123 4567
	                | ((tk->slices[1] & 0x0010) << 4)   //              0000 0000 0001 0000 | 9080 A0CB Z123 4567
	                | ((tk->slices[1] & 0x0004) << 10)  //              0000 0000 0000 0100 | 9080 AECB Z123 4567
	                | ((tk->slices[1] & 0x0002) << 9)   //              0000 0000 0000 0010 | 908D AECB Z123 4567
	                | ((tk->slices[1] & 0x0001) << 14); //              0000 0000 0000 0001 | 9F8D AECB Z123 4567
	
	// --------------------------------------------------- source bits: Z123 4567 89ab cdef	| Cumulative value
	tk->slices[2] = ((tk->slices[2] & 0xFF00) >> 8)     // masks:       1111 1111 0000 0000 | 0000 0000 Z123 4567
	                | ((tk->slices[2] & 0x00A8) << 6)   //              0000 0000 1010 1000 | 0080 A0C0 Z123 4567
	                | ((tk->slices[2] & 0x0040) << 9)   //              0000 0000 0100 0000 | 9080 A0C0 Z123 4567
	                | ((tk->slices[2] & 0x0010) << 4)   //              0000 0000 0001 0000 | 9080 A0CB Z123 4567
	                | ((tk->slices[2] & 0x0004) << 10)  //              0000 0000 0000 0100 | 9080 AECB Z123 4567
	                | ((tk->slices[2] & 0x0002) << 9)   //              0000 0000 0000 0010 | 908D AECB Z123 4567
	                | ((tk->slices[2] & 0x0001) << 14); //              0000 0000 0000 0001 | 9F8D AECB Z123 4567
	
	// --------------------------------------------------- source bits: Z123 4567 89ab cdef	| Cumulative value
	tk->slices[3] = ((tk->slices[3] & 0xFF00) >> 8)     // masks:       1111 1111 0000 0000 | 0000 0000 Z123 4567
	                | ((tk->slices[3] & 0x00A8) << 6)   //              0000 0000 1010 1000 | 0080 A0C0 Z123 4567
	                | ((tk->slices[3] & 0x0040) << 9)   //              0000 0000 0100 0000 | 9080 A0C0 Z123 4567
	                | ((tk->slices[3] & 0x0010) << 4)   //              0000 0000 0001 0000 | 9080 A0CB Z123 4567
	                | ((tk->slices[3] & 0x0004) << 10)  //              0000 0000 0000 0100 | 9080 AECB Z123 4567
	                | ((tk->slices[3] & 0x0002) << 9)   //              0000 0000 0000 0010 | 908D AECB Z123 4567
	                | ((tk->slices[3] & 0x0001) << 14); //              0000 0000 0000 0001 | 9F8D AECB Z123 4567
}

static inline void permute_sliced_step(State64Sliced_16_t *tk) {
	// extract slices for simplicity
	auto slice0 = tk->slices[0];
	auto slice1 = tk->slices[1];
	auto slice2 = tk->slices[0];
	auto slice3 = tk->slices[3];
	
	// save top 2 rows
	auto slice0_row_1_2 = ((slice0 & 0xFF00));
	auto slice1_row_1_2 = ((slice1 & 0xFF00));
	auto slice2_row_1_2 = ((slice2 & 0xFF00));
	auto slice3_row_1_2 = ((slice3 & 0xFF00));
	
	// save last 2 rows
	auto slice0_row_3_4 = (slice0 & 0x00FF);
	auto slice1_row_3_4 = (slice1 & 0x00FF);
	auto slice2_row_3_4 = (slice2 & 0x00FF);
	auto slice3_row_3_4 = (slice3 & 0x00FF);
	
	// PT[8, 10, 12]
	slice0_row_3_4 |= ((slice0_row_3_4 & 0b10101000) >> 2);
	slice1_row_3_4 |= ((slice1_row_3_4 & 0b10101000) >> 2);
	slice2_row_3_4 |= ((slice2_row_3_4 & 0b10101000) >> 2);
	slice3_row_3_4 |= ((slice3_row_3_4 & 0b10101000) >> 2);
	
	
	// PT[9]
	slice0_row_3_4 |= ((slice0_row_3_4 & 0b01000000) << 1);
	slice1_row_3_4 |= ((slice1_row_3_4 & 0b01000000) << 1);
	slice2_row_3_4 |= ((slice2_row_3_4 & 0b01000000) << 1);
	slice3_row_3_4 |= ((slice3_row_3_4 & 0b01000000) << 1);
	
	// PT[11]
	slice0_row_3_4 |= (slice0_row_3_4 & 0b00010000) >> 4;
	slice1_row_3_4 |= (slice1_row_3_4 & 0b00010000) >> 4;
	slice2_row_3_4 |= (slice2_row_3_4 & 0b00010000) >> 4;
	slice3_row_3_4 |= (slice3_row_3_4 & 0b00010000) >> 4;
	
	// PT[13]
	slice0_row_3_4 |= (slice0_row_3_4 & 0b00000100) << 2;
	slice1_row_3_4 |= (slice1_row_3_4 & 0b00000100) << 2;
	slice2_row_3_4 |= (slice2_row_3_4 & 0b00000100) << 2;
	slice3_row_3_4 |= (slice3_row_3_4 & 0b00000100) << 2;
	
	// PT[14]
	slice0_row_3_4 |= (slice0_row_3_4 & 0b00000010) << 1;
	slice1_row_3_4 |= (slice1_row_3_4 & 0b00000010) << 1;
	slice2_row_3_4 |= (slice2_row_3_4 & 0b00000010) << 1;
	slice3_row_3_4 |= (slice3_row_3_4 & 0b00000010) << 1;
	
	// PT[15]
	slice0_row_3_4 |= (slice0_row_3_4 & 0b00000001) << 6;
	slice1_row_3_4 |= (slice1_row_3_4 & 0b00000001) << 6;
	slice2_row_3_4 |= (slice2_row_3_4 & 0b00000001) << 6;
	slice3_row_3_4 |= (slice3_row_3_4 & 0b00000001) << 6;
	
	tk->slices[0] = (slice0_row_3_4 << 8) | slice0_row_1_2;
	tk->slices[1] = (slice1_row_3_4 << 8) | slice1_row_1_2;
	tk->slices[2] = (slice2_row_3_4 << 8) | slice2_row_1_2;
	tk->slices[3] = (slice3_row_3_4 << 8) | slice3_row_1_2;
}

static inline void permute_old(State64_t *tk) {
	/* PT = [9, 15, 8, 13, 10, 14, 12, 11, 0, 1, 2, 3, 4, 5, 6, 7] */
	/* Permutation generated by http://programming.sirrida.de/calcperm.php */
//	uint32_t x = tk->lrow[1];
//	tk->lrow[1] = tk->lrow[0];
//	tk->lrow[0] = ((x & 0x0000000FU) << 4) |
//	              ((x & 0x00F0F0F0U) << 8) |
//	              ((x & 0x0F000000U) >> 24) |
//	              ((x & 0x00000F00U) << 16) |
//	              ((x & 0xF0000000U) >> 12) |
//	              ((x & 0x000F0000U) >> 8);
	
	uint16_t row2 = tk->row[2];
	uint16_t row3 = tk->row[3];
	tk->row[2] = tk->row[0];
	tk->row[3] = tk->row[1];
	row3 = (row3 << 8) | (row3 >> 8);
	tk->row[0] = ((row2 << 4) & 0x00F0U) |
	             ((row2 << 8) & 0xF000U) |
	             (row3       & 0x0F0FU);
	tk->row[1] = ((row2 >> 8) & 0x00F0U) |
	             (row2       & 0x0F00U) |
	             ((row3 >> 4) & 0x000FU) |
	             ( row3       & 0xF000U);
}


int main(int argc, char **argv) {
	uint64_t state = 0x0123456789abcdef;
	(((uint64_t) rand()) << 32) | ((uint64_t) rand());  // 2⁶⁴
	
	auto sliced1 = State64Sliced_16_t();
	sliced1.state = slice(state);
	
	auto sliced2 = State64Sliced_16_t();
	sliced2.state = slice(state);
	
	auto vanilla = State64_t();
	vanilla.llrow = state;
	
	permute_old(&vanilla);
	permute_sliced_step(&sliced1);
	permute_sliced_circuit(&sliced2);
	
	uint64_t unsliced_state2 = unslice(sliced2.state);
	uint64_t unsliced_state1 = unslice(sliced1.state);
	
	assert(vanilla.llrow == unsliced_state1);
	assert(unsliced_state1 == unsliced_state2);
	
	std::cout << "State was equal: " << unsliced_state1;
}