#include "../forkskinny-plus/headers/forkskinny64-plus.h"
#include "../headers/full-state-slicing.h"
#include <cstdint>
#include "cassert"
#include <iostream>
#include "cstdlib"

static inline void permute_sliced_packed_32(State64Sliced_16_t *tk) {
	// avoid too much *tk address lookups by putting slices in local variables
	auto slice0 = tk->slices[0];
	auto slice1 = tk->slices[1];
	auto slice2 = tk->slices[2];
	auto slice3 = tk->slices[3];
	
	// unpack the bottom 2 rows of every slice_t in a single 32 bit word
	// i.e.: r3⁰r4⁰ | r3¹r4¹ | r3²r4² | r3³r4³
	uint32_t packed_slices =
			((slice0 & 0x00FF) << 24)
			| ((slice1 & 0x00FF) << 16)
			| ((slice2 & 0x00FF) << 8)
			| (slice3 & 0x00FF);
	
	// perform permutation on the packed rows of the slices
	uint32_t packed_permuted_slices =
			((packed_slices & 0xA8A8A8A8) >> 2)
			| ((packed_slices & 0x40404040) << 1)
			| ((packed_slices & 0x10101010) >> 4)
			| ((packed_slices & 0x04040404) << 2)
			| ((packed_slices & 0x02020202) << 1)
			| ((packed_slices & 0x01010101) << 6);
	
	// unpack results & reconstruct slices
	tk->slices[0] = ((packed_permuted_slices & 0xFF000000) >> 16) | ((slice0 & 0xFF00) >> 8);
	tk->slices[1] = ((packed_permuted_slices & 0x00FF0000) >> 8) | ((slice1 & 0xFF00) >> 8);
	tk->slices[2] = (packed_permuted_slices & 0x0000FF00) | ((slice2 & 0xFF00) >> 8);
	tk->slices[3] = ((packed_permuted_slices & 0x000000FF) << 8) | ((slice3 & 0xFF00) >> 8);
}

static inline void permute_sliced_packed_16(State64Sliced_16_t *tk) {
	// avoid too much *tk address lookups by putting slices in local variables
	auto slice0 = tk->slices[0];
	auto slice1 = tk->slices[1];
	auto slice2 = tk->slices[2];
	auto slice3 = tk->slices[3];
	
	// unpack the bottom 2 rows of the first 2 slices in 1 16-bit variable
	uint16_t slice_0_1 = ((slice0 & 0x00FF) << 8) | (slice1 & 0x00FF);
	
	// unpack the bottom 2 rows of the last 2 slices in 1 16-bit variable
	uint16_t slice_2_3 = ((slice2 & 0x00FF) << 8) | (slice3 & 0x00FF);
	
	// perform permutation on first 2 slices
	uint16_t permuted_slice_0_1 =             // source bits: 89ab cdef 89ab cdef
			((slice_0_1 & 0xA8A8) >> 2)       //              1010 1000 1010 1000 | 0080 A0C0 0080 A0C0
			| ((slice_0_1 & 0x4040) << 1)     //              0100 0000 0100 0000 | 9080 A0C0 9080 A0C0
			| ((slice_0_1 & 0x1010) >> 4)     //              0001 0000 0001 0000 | 9080 A0CB 9080 A0CB
			| ((slice_0_1 & 0x0404) << 2)     //              0000 0100 0000 0100 | 9080 AECB 9080 AECB
			| ((slice_0_1 & 0x0202) << 1)     //              0000 0010 0000 0010 | 908D AECB 908D AECB
			| ((slice_0_1 & 0x0101) << 6);    //              0000 0001 0000 0001 | 9F8D AECB 9F8D AECB
	
	// perform permutation on last 2 slices
	uint16_t permuted_slice_2_3 =
			((slice_2_3 & 0xA8A8) >> 2)       //              1010 1000 1010 1000 | 0080 A0C0 0080 A0C0
			| ((slice_2_3 & 0x4040) << 1)     //              0100 0000 0100 0000 | 9080 A0C0 9080 A0C0
			| ((slice_2_3 & 0x1010) >> 4)     //              0001 0000 0001 0000 | 9080 A0CB 9080 A0CB
			| ((slice_2_3 & 0x0404) << 2)     //              0000 0100 0000 0100 | 9080 AECB 9080 AECB
			| ((slice_2_3 & 0x0202) << 1)     //              0000 0010 0000 0010 | 908D AECB 908D AECB
			| ((slice_2_3 & 0x0101) << 6);    //              0000 0001 0000 0001 | 9F8D AECB 9F8D AECB
	
	// unpack results & reconstruct slices
	tk->slices[0] = (permuted_slice_0_1 & 0xFF00) | ((slice0 & 0xFF00) >> 8);
	tk->slices[1] = ((permuted_slice_0_1 & 0x00FF) << 8) | ((slice1 & 0xFF00) >> 8);
	tk->slices[2] = (permuted_slice_2_3 & 0xFF00) | ((slice2 & 0xFF00) >> 8);
	tk->slices[3] = ((permuted_slice_2_3 & 0x00FF) << 8) | ((slice3 & 0xFF00) >> 8);
}

// for every slice_t: PT[9, 15, 8, 13, 10, 14, 12, 11, 0, 1, 2, 3, 4, 5, 6, 7] (source indices)
/* Permutation generated by http://programming.sirrida.de/calcperm.php */
static inline void permute_sliced_packed_8(State64Sliced_16_t *tk) {
	uint16_t slice0 = tk->slices[0];
	uint16_t slice1 = tk->slices[1];
	uint16_t slice2 = tk->slices[2];
	uint16_t slice3 = tk->slices[3];
	// --------------------------------------------------- source bits: Z123 4567 89ab cdef	| Cumulative raw
	tk->slices[0] = ((slice0 & 0xFF00) >> 8)     // masks:       1111 1111 0000 0000 | 0000 0000 Z123 4567
	                | ((slice0 & 0x00A8) << 6)   //              0000 0000 1010 1000 | 0080 A0C0 Z123 4567
	                | ((slice0 & 0x0040) << 9)   //              0000 0000 0100 0000 | 9080 A0C0 Z123 4567
	                | ((slice0 & 0x0010) << 4)   //              0000 0000 0001 0000 | 9080 A0CB Z123 4567
	                | ((slice0 & 0x0004) << 10)  //              0000 0000 0000 0100 | 9080 AECB Z123 4567
	                | ((slice0 & 0x0002) << 9)   //              0000 0000 0000 0010 | 908D AECB Z123 4567
	                | ((slice0 & 0x0001) << 14); //              0000 0000 0000 0001 | 9F8D AECB Z123 4567
	
	// --------------------------------------------------- source bits: Z123 4567 89ab cdef	| Cumulative raw
	tk->slices[1] = ((slice1 & 0xFF00) >> 8)     // masks:       1111 1111 0000 0000 | 0000 0000 Z123 4567
	                | ((slice1 & 0x00A8) << 6)   //              0000 0000 1010 1000 | 0080 A0C0 Z123 4567
	                | ((slice1 & 0x0040) << 9)   //              0000 0000 0100 0000 | 9080 A0C0 Z123 4567
	                | ((slice1 & 0x0010) << 4)   //              0000 0000 0001 0000 | 9080 A0CB Z123 4567
	                | ((slice1 & 0x0004) << 10)  //              0000 0000 0000 0100 | 9080 AECB Z123 4567
	                | ((slice1 & 0x0002) << 9)   //              0000 0000 0000 0010 | 908D AECB Z123 4567
	                | ((slice1 & 0x0001) << 14); //              0000 0000 0000 0001 | 9F8D AECB Z123 4567
	
	// --------------------------------------------------- source bits: Z123 4567 89ab cdef	| Cumulative raw
	tk->slices[2] = ((slice2 & 0xFF00) >> 8)     // masks:       1111 1111 0000 0000 | 0000 0000 Z123 4567
	                | ((slice2 & 0x00A8) << 6)   //              0000 0000 1010 1000 | 0080 A0C0 Z123 4567
	                | ((slice2 & 0x0040) << 9)   //              0000 0000 0100 0000 | 9080 A0C0 Z123 4567
	                | ((slice2 & 0x0010) << 4)   //              0000 0000 0001 0000 | 9080 A0CB Z123 4567
	                | ((slice2 & 0x0004) << 10)  //              0000 0000 0000 0100 | 9080 AECB Z123 4567
	                | ((slice2 & 0x0002) << 9)   //              0000 0000 0000 0010 | 908D AECB Z123 4567
	                | ((slice2 & 0x0001) << 14); //              0000 0000 0000 0001 | 9F8D AECB Z123 4567
	
	// --------------------------------------------------- source bits: Z123 4567 89ab cdef	| Cumulative raw
	tk->slices[3] = ((slice3 & 0xFF00) >> 8)     // masks:       1111 1111 0000 0000 | 0000 0000 Z123 4567
	                | ((slice3 & 0x00A8) << 6)   //              0000 0000 1010 1000 | 0080 A0C0 Z123 4567
	                | ((slice3 & 0x0040) << 9)   //              0000 0000 0100 0000 | 9080 A0C0 Z123 4567
	                | ((slice3 & 0x0010) << 4)   //              0000 0000 0001 0000 | 9080 A0CB Z123 4567
	                | ((slice3 & 0x0004) << 10)  //              0000 0000 0000 0100 | 9080 AECB Z123 4567
	                | ((slice3 & 0x0002) << 9)   //              0000 0000 0000 0010 | 908D AECB Z123 4567
	                | ((slice3 & 0x0001) << 14); //              0000 0000 0000 0001 | 9F8D AECB Z123 4567
}

static inline void permute_sliced_step(State64Sliced_16_t *tk) {
	// extract slices for simplicity
	auto slice0 = tk->slices[0];
	auto slice1 = tk->slices[1];
	auto slice2 = tk->slices[2];
	auto slice3 = tk->slices[3];
	
	// save top 2 rows
	auto slice0_row_1_2 = ((slice0 & 0xFF00));
	auto slice1_row_1_2 = ((slice1 & 0xFF00));
	auto slice2_row_1_2 = ((slice2 & 0xFF00));
	auto slice3_row_1_2 = ((slice3 & 0xFF00));
	
	// save last 2 rows
	auto slice0_row_3_4 = (slice0 & 0x00FF);
	auto slice1_row_3_4 = (slice1 & 0x00FF);
	auto slice2_row_3_4 = (slice2 & 0x00FF);
	auto slice3_row_3_4 = (slice3 & 0x00FF);
	
	// PT[8, A, C]
	uint16_t res_slice0_row_3_4 = ((slice0_row_3_4 & 0b10101000) >> 2);
	uint16_t res_slice1_row_3_4 = ((slice1_row_3_4 & 0b10101000) >> 2);
	uint16_t res_slice2_row_3_4 = ((slice2_row_3_4 & 0b10101000) >> 2);
	uint16_t res_slice3_row_3_4 = ((slice3_row_3_4 & 0b10101000) >> 2);
	
	
	// PT[9]
	res_slice0_row_3_4 |= ((slice0_row_3_4 & 0b01000000) << 1);
	res_slice1_row_3_4 |= ((slice1_row_3_4 & 0b01000000) << 1);
	res_slice2_row_3_4 |= ((slice2_row_3_4 & 0b01000000) << 1);
	res_slice3_row_3_4 |= ((slice3_row_3_4 & 0b01000000) << 1);
	
	// PT[B]
	res_slice0_row_3_4 |= (slice0_row_3_4 & 0b00010000) >> 4;
	res_slice1_row_3_4 |= (slice1_row_3_4 & 0b00010000) >> 4;
	res_slice2_row_3_4 |= (slice2_row_3_4 & 0b00010000) >> 4;
	res_slice3_row_3_4 |= (slice3_row_3_4 & 0b00010000) >> 4;
	
	// PT[D]
	res_slice0_row_3_4 |= (slice0_row_3_4 & 0b00000100) << 2;
	res_slice1_row_3_4 |= (slice1_row_3_4 & 0b00000100) << 2;
	res_slice2_row_3_4 |= (slice2_row_3_4 & 0b00000100) << 2;
	res_slice3_row_3_4 |= (slice3_row_3_4 & 0b00000100) << 2;
	
	// PT[E]
	res_slice0_row_3_4 |= (slice0_row_3_4 & 0b00000010) << 1;
	res_slice1_row_3_4 |= (slice1_row_3_4 & 0b00000010) << 1;
	res_slice2_row_3_4 |= (slice2_row_3_4 & 0b00000010) << 1;
	res_slice3_row_3_4 |= (slice3_row_3_4 & 0b00000010) << 1;
	
	// PT[F]
	res_slice0_row_3_4 |= (slice0_row_3_4 & 0b00000001) << 6;
	res_slice1_row_3_4 |= (slice1_row_3_4 & 0b00000001) << 6;
	res_slice2_row_3_4 |= (slice2_row_3_4 & 0b00000001) << 6;
	res_slice3_row_3_4 |= (slice3_row_3_4 & 0b00000001) << 6;
	
	tk->slices[0] = (res_slice0_row_3_4 << 8) | (slice0_row_1_2 >> 8);
	tk->slices[1] = (res_slice1_row_3_4 << 8) | (slice1_row_1_2 >> 8);
	tk->slices[2] = (res_slice2_row_3_4 << 8) | (slice2_row_1_2 >> 8);
	tk->slices[3] = (res_slice3_row_3_4 << 8) | (slice3_row_1_2 >> 8);
}

static inline void permute_old(State64_t *tk) {
	/* PT = [9, 15, 8, 13, 10, 14, 12, 11, 0, 1, 2, 3, 4, 5, 6, 7] */
	/* Permutation generated by http://programming.sirrida.de/calcperm.php */
//	uint32_t x = tk->lrow[1];
//	tk->lrow[1] = tk->lrow[0];
//	tk->lrow[0] = ((x & 0x0000000FU) << 4) |
//	              ((x & 0x00F0F0F0U) << 8) |
//	              ((x & 0x0F000000U) >> 24) |
//	              ((x & 0x00000F00U) << 16) |
//	              ((x & 0xF0000000U) >> 12) |
//	              ((x & 0x000F0000U) >> 8);
	
	uint16_t row2 = tk->row[2];
	uint16_t row3 = tk->row[3];
	tk->row[2] = tk->row[0];
	tk->row[3] = tk->row[1];
	row3 = (row3 << 8) | (row3 >> 8);
	tk->row[0] = ((row2 << 4) & 0x00F0U) |
	             ((row2 << 8) & 0xF000U) |
	             (row3 & 0x0F0FU);
	tk->row[1] = ((row2 >> 8) & 0x00F0U) |
	             (row2 & 0x0F00U) |
	             ((row3 >> 4) & 0x000FU) |
	             (row3 & 0xF000U);
}


int main(int argc, char **argv) {
	u64 state = 0x0123456789abcdef;
	(((u64) rand()) << 32) | ((u64) rand());  // 2⁶⁴
	
	auto sliced_step = State64Sliced_16_t();
	sliced_step.state = slice(state);
	
	auto sliced_packed_8 = State64Sliced_16_t();
	sliced_packed_8.state = slice(state);
	
	auto sliced_packed_16 = State64Sliced_16_t();
	sliced_packed_16.state = slice(state);
	
	auto sliced_packed_32 = State64Sliced_16_t();
	sliced_packed_32.state = slice(state);
	
	auto vanilla = State64_t();
	vanilla.llrow = state;
	
	permute_old(&vanilla);
	permute_sliced_step(&sliced_step);
	permute_sliced_packed_8(&sliced_packed_8);
	permute_sliced_packed_16(&sliced_packed_16);
	permute_sliced_packed_32(&sliced_packed_32);
	
	u64 unsliced_step = unslice_accelerated(sliced_step.state);
	u64 unsliced_packed_8 = unslice_accelerated(sliced_packed_8.state);
	u64 unsliced_packed_16 = unslice_accelerated(sliced_packed_16.state);
	u64 unsliced_packed_32 = unslice_accelerated(sliced_packed_32.state);
	
	assert(unsliced_packed_8 == unsliced_step);
	assert(unsliced_packed_8 == vanilla.llrow);
	assert(unsliced_packed_8 == unsliced_packed_16);
	assert(unsliced_packed_8 == unsliced_packed_32);
	
	std::cout << "State was equal: " << unsliced_step;
}