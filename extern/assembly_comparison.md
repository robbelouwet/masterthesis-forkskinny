## Benchmarking the LSFR for TK2

The following results can be generated by checking out commit $$$$, build the executable and perform an objdump using
the dump.sh file, then look for the benchmark_lsfr function in the objdump. In this function, 3 versions of the same
LSFR are performed. One with plain bitslicing + simd, one with plain bit slicing and one non-bitsliced sequential LSFR.
The first one (bit slicing + simd) is delimited with 2 NOP instructions, the second one (plain bit slicing) with 3
NOP instructions, and the last one (sequential non-bit sliced) is delimited with 4 NOP instructions.

<table>

<tr>
<th>64-bit x86</th>
<th>Source Code</th>
</tr>

<tr>
<td>

```assembly
    141b:	0f 6f 04 24          	movq   mm0,QWORD PTR [rsp]
    141f:	0f 70 c0 93          	pshufw mm0,mm0,0x93
    1423:	0f 7f 04 24          	movq   QWORD PTR [rsp],mm0
    1427:	0f b7 54 24 06       	movzx  edx,WORD PTR [rsp+0x6]
    142c:	0f b7 04 24          	movzx  eax,WORD PTR [rsp]
    1430:	31 d0                	xor    eax,edx
    1432:	66 89 04 24          	mov    WORD PTR [rsp],ax
```

</td>
<td>

```cpp
sliced.m64state = _mm_shuffle_pi16(sliced.m64state, 0b10010011);
sliced.slices[0] ^= sliced.slices[3];
```

</td>

</tr>
<tr>
<td>

```assembly
    18b0:	48 8b 45 b0          	mov    rax,QWORD PTR [rbp-0x50]
    18b4:	48 0f 6e c0          	movq   mm0,rax
    18b8:	0f 70 c0 93          	pshufw mm0,mm0,0x93
    18bc:	48 0f 7e c0          	movq   rax,mm0
    18c0:	48 89 45 b0          	mov    QWORD PTR [rbp-0x50],rax
    18c4:	0f b7 55 b0          	movzx  edx,WORD PTR [rbp-0x50]
    18c8:	0f b7 45 b6          	movzx  eax,WORD PTR [rbp-0x4a]
    18cc:	31 d0                	xor    eax,edx
    18ce:	66 89 45 b0          	mov    WORD PTR [rbp-0x50],ax
```

</td>
<td>

```cpp
sliced.m64state = _mm_shuffle_pi16(sliced.m64state, 0b10010011);
sliced.slices[0] ^= sliced.slices[3];
```

</td>

</tr>
</table>


